from matchthetiles.gamestate.tiledata import WallData, BlockData, GoalData
from matchthetiles.utils.coords import Coords

import numpy as np

from collections import defaultdict
from copy import deepcopy
from enum import Enum
import math
import sys

class Move(Enum):
    SWIPE_LEFT = 0
    SWIPE_UP = 1
    SWIPE_RIGHT = 2
    SWIPE_DOWN = 3

    def __str__(self):
        if self.name == "SWIPE_DOWN":
            return "Down"
        if self.name == "SWIPE_LEFT":
            return "Left"
        if self.name == "SWIPE_RIGHT":
            return "Right"
        if self.name == "SWIPE_UP":
            return "Up"

class CommonGameState:
    def __init__(self, walls: list, goals: list, rows: int, cols: int):
        """
        Constructor
        - List walls : List of coordinates of the walls (i.e. [x, y])
        - List goals : List of coordinates and colors of the goals (i.e. [x, y, color])
        - Int rows : Number of rows in the game board
        - Int cols : Number of cols in the game board
        """
        self.walls = list()
        for wall in walls:
            self.walls.append(WallData(Coords(wall[0], wall[1])))

        self.goals = list()
        for goal in goals:
            self.goals.append(GoalData(Coords(goal[0], goal[1]), goal[2]))

        self.rows = rows
        self.cols = cols


class GameState:
    def __init__(self, common_gs, blocks):
        """
        Constructor
        - CommonGameState common_gs : GameState containing the non-movable tiles
        - List blocks : List of coordinates and colors of the blocks (i.e. [x, y, color])
        - Move move : Move that originated GameState, None if initial
        - Int nMoves : Number of moves since initial state
        """
        self.common_gs = common_gs
        self.blocks = list()
        for block in blocks:
            self.blocks.append(BlockData(Coords(block[0], block[1]), block[2]))

    def __repr__(self):
        out = ""
        matrix = self.getGameStateMatrix()
        for i in matrix:
            out += "\n"
            for j in i:
                out += j + "\t"
        out += "\n"
        return out

    def getGameStateMatrix(self):
        """
        Makes A Matrix with the board
        """
        matrix = []
        for i in range(self.common_gs.rows):
            line = []
            for j in range(self.common_gs.cols):
                coord = Coords(i, j)
                tipo = "."
                for block in self.blocks:
                    if coord == block.coords:
                        tipo = block.color
                        break
                for goal in self.common_gs.goals:
                    if tipo != ".":
                        break
                    if coord == goal.coords:
                        tipo = goal.color
                        break
                for wall in self.common_gs.walls:
                    if tipo != ".":
                        break
                    if coord == wall.coords:
                        tipo = "#"
                        break
                line.append(tipo)
            matrix.append(line)
        return matrix

    @staticmethod
    def blocks_as_list(blocks):
        block_l = list()
        for block in blocks:
            block_l.append([block.coords.x, block.coords.y, block.color])

        return block_l

    def make_blocks_copy(self):
        copy_blocks = list()
        for block in self.blocks:
            copy_blocks.append(BlockData(Coords(block.coords.x, block.coords.y), block.color))

        return copy_blocks

    def getGameStateDictionary(self):
        """
        Makes A Dictionary with the board
        """
        d = defaultdict(list)
        for block in self.blocks:
            d[block.coords].append(block.color)
        for goal in self.common_gs.goals:
            d[goal.coords].append(goal.color)
        for wall in self.common_gs.walls:
            d[wall.coords].append("#")
        return d

    def is_game_over(self):
        """
        Checks if game state is in final state, each block must match in one goal

        Returns true if represents a final state, false otherwise
        """
        for block in self.blocks:
            found = False
            for goal in self.common_gs.goals:
                if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                    found = True
                    break
            if not found:
                return False
        return True


    def swipe_left(self):
        """
        Swipe Left Operation - Moves the movable blocks in the GameState to the left

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: el.coords.y)
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y < block.coords.y,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.y)
            new_col = walls[0].coords.y + 1 if walls else 0
            self.blocks[i].coords.setY(new_col)

    """
    Swipe Left Operation - Moves the movable blocks in the GameState to the left
    Returns the new GameState generated by that operation
    """

    def reverse_swipe_left(self):
        new_blocks = self.make_blocks_copy()
        new_blocks.sort(key=lambda el: el.coords.y)
        for i in range(len(new_blocks)):
            block = new_blocks[i]
            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y < block.coords.y,
                                  new_blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.y)
            new_col = walls[0].coords.y + 1 if walls else 0
            new_blocks[i].coords.setY(new_col)

        return GameState(self.common_gs, self.blocks_as_list(new_blocks))

    def swipe_right(self):
        """
        Swipe Right Operation - Moves the movable blocks in the GameState to the right

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: -el.coords.y)
        for i in range(len(self.blocks)):
            block = self.blocks[i]

            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y > block.coords.y,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.y)
            new_col = walls[0].coords.y - 1 if walls else (self.common_gs.cols - 1)
            self.blocks[i].coords.setY(new_col)

    def reverse_swipe_right(self):
        new_blocks = self.make_blocks_copy()
        new_blocks.sort(key=lambda el: -el.coords.y)
        for i in range(len(new_blocks)):
            block = new_blocks[i]
            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y > block.coords.y,
                                  new_blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.y)
            new_col = walls[0].coords.y - 1 if walls else (self.common_gs.cols - 1)
            new_blocks[i].coords.setY(new_col)

        return GameState(self.common_gs, self.blocks_as_list(new_blocks))

    def swipe_up(self):
        """
        Swipe Up Operation - Moves the movable blocks in the GameState upwards

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: el.coords.x)
        for i in range(len(self.blocks)):
            block = self.blocks[i]

            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x < block.coords.x,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.x)
            new_row = walls[0].coords.x + 1 if walls else 0
            self.blocks[i].coords.setX(new_row)

    def reverse_swipe_up(self):
        new_blocks = self.make_blocks_copy()
        new_blocks.sort(key=lambda el: el.coords.x)
        for i in range(len(new_blocks)):
            block = new_blocks[i]
            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x < block.coords.x,
                                  new_blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.x)
            new_row = walls[0].coords.x + 1 if walls else 0
            new_blocks[i].coords.setX(new_row)
        return GameState(self.common_gs, self.blocks_as_list(new_blocks))
            
    def swipe_down(self):
        """
        Swipe Down Operation - Moves the movable blocks in the GameState downwards

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: -el.coords.x)
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x > block.coords.x,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.x)
            new_row = walls[0].coords.x - 1 if walls else (self.common_gs.rows - 1)
            self.blocks[i].coords.setX(new_row)
    
    def reverse_swipe_down(self):
        new_blocks = self.make_blocks_copy()
        new_blocks.sort(key=lambda el: -el.coords.x)
        for i in range(len(new_blocks)):
            block = new_blocks[i]
            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x > block.coords.x,
                                  new_blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.x)
            new_row = walls[0].coords.x - 1 if walls else (self.common_gs.rows - 1)
            new_blocks[i].coords.setX(new_row)

        return GameState(self.common_gs, self.blocks_as_list(new_blocks))

    def is_on_goal(self, block):
        for goal in self.common_gs.goals:
            if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                return True
        return False

    def number_of_blocks_on_goals(self):
        n = 0
        for block in self.blocks:
            for goal in self.common_gs.goals:
                if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                    n += 1
                    break
        return n

    def euclidean_distance(self):
        dists = []
        for block in self.blocks:
            node_dists = []
            for goal in self.common_gs.goals:
                if block.color == goal.color:
                    # d = sqrt((x2-x1)**2 + (y2-y1)**2)
                    dnode = math.sqrt(
                        math.pow(block.coords.x - goal.coords.x, 2) + math.pow(block.coords.y - goal.coords.y, 2))
                    node_dists.append(dnode)
            if node_dists:
                d = min(node_dists)
            else:
                d = sys.maxsize
            dists.append(d)
        return min(dists)

    @staticmethod
    def generate_game_state(n_blocks, n_walls, rows, cols):
        walls = list()
        goals = list()
        blocks = list()

        level = np.zeros((rows, cols), dtype=str)

        level, walls = GameState.generate_level_walls(level, n_walls, rows, cols)
        level, goals = GameState.generate_level_goals(level, n_blocks, rows, cols)
        blocks = GameState.generate_level_blocks(walls, goals, rows, cols)

        common_gs = CommonGameState(walls, goals, rows, cols)
        return GameState(common_gs, blocks)

    @staticmethod
    def generate_level_walls(level, n_walls, rows, cols):
        walls = list()
        for i in range(n_walls):
        
            x = np.random.randint(0, rows)
            y = np.random.randint(0, cols)

            while (level[x, y] != ''):
                x = np.random.randint(0, rows)
                y = np.random.randint(0, cols)
            
            level[x, y] = '#'
            walls.append((x, y))    
        

        return level, walls

    @staticmethod
    def generate_level_goals(level, n_goals, rows, cols):
        goals = list()

        for i in range(n_goals):
            x = np.random.randint(0, rows)
            y = np.random.randint(0, cols)

            while True:
                if (level[x,y] == ''):
                    n_obstacles = 0
                    # Left
                    n_obstacles += (y == 0 or level[x, y - 1] != '')
                    # Right
                    n_obstacles += (y == cols - 1 or level[x, y + 1] != '')
                    # Up
                    n_obstacles += (x == 0 or level[x - 1, y] != '')
                    # Down
                    n_obstacles += (x == rows - 1 or level[x + 1, y] != '')

                    if (n_obstacles >= 1 and n_obstacles < 4): break

                x = np.random.randint(0, rows)
                y = np.random.randint(0, cols)

            level[x, y] = chr(ord('A') + i)
            goals.append((x, y, level[x, y]))

        return level, goals

    @staticmethod
    def generate_level_blocks(walls, goals, rows, cols, max_steps=9000):
        blocks = []

        for goal in goals:
            blocks.append((goal[0], goal[1], goal[2].lower()))

        #for i in range(len(blocks)):
         #   blocks[i] = tuple([blocks[i][0], blocks[i][1], blocks[i][2].lower()])

        commonGamestate = CommonGameState(walls, goals, rows, cols)

        gameState = GameState(commonGamestate, blocks)

        best_state = GameState.reverse_play(gameState, max_steps)

        return GameState.blocks_as_list(best_state.blocks)

    @staticmethod
    def reverse_play(gamestate, max_steps):

        visited = defaultdict(bool)

        queue = [gamestate]

        best_state = None
        best_score = -1

        while queue:
            current = queue.pop(0)

            score = current.euclidean_distance()

            if (score > best_score):
                best_score = score
                best_state = current

            if (max_steps == 0):
                break

            max_steps -= 1

            visited[current] = True

            for edge in current.get_edges():
                if (visited[edge]):
                    continue
                queue.insert(0, edge)

        print(f"Best score: {best_score}")
        return best_state

    def euclidean_distance(self, dist_func=min, node_func=min):
        dists = []
        for block in self.blocks:
            node_dists = []
            for goal in self.common_gs.goals:
                if block.color.lower() == goal.color.lower():
                    # d = sqrt((x2-x1)**2 + (y2-y1)**2)
                    dnode = math.sqrt(
                        math.pow(block.coords.x - goal.coords.x, 2) + math.pow(block.coords.y - goal.coords.y, 2))
                    node_dists.append(dnode)
            if node_dists:
                d = node_func(node_dists)
            else:
                d = sys.maxsize
            dists.append(d)
        return dist_func(dists)


        
    def get_edges(self):
        edges = [self.reverse_swipe_left(), self.reverse_swipe_right(), self.reverse_swipe_up(),
                 self.reverse_swipe_down()]
        return edges

    def __eq__(self, other):
        if other is None:
            return False
        self_blocks = sorted(self.blocks, key=lambda el: (el.coords.x, el.coords.y, el.color))
        other_blocks = sorted(other.blocks, key=lambda el: (el.coords.x, el.coords.y, el.color))
        return all(map(lambda x, y: x == y, self_blocks, other_blocks))

    def __hash__(self):
        return hash(self.__str__())


        