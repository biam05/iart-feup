from matchthetiles.gamestate.tiledata import WallData, BlockData, GoalData
from matchthetiles.utils.utils import Coords

from collections import defaultdict
from copy import deepcopy
from enum import Enum
import math
import sys

class Move(Enum):
    SWIPE_LEFT = 0
    SWIPE_UP = 1
    SWIPE_RIGHT = 2
    SWIPE_DOWN = 3

    def __str__(self):
        if self.name == "SWIPE_DOWN":
            return "Down"
        if self.name == "SWIPE_LEFT":
            return "Left"
        if self.name == "SWIPE_RIGHT":
            return "Right"
        if self.name == "SWIPE_UP":
            return "Up"

class CommonGameState:
    def __init__(self, walls: list, goals: list, rows: int, cols: int):
        """
        Constructor
        - List walls : List of coordinates of the walls (i.e. [x, y])
        - List goals : List of coordinates and colors of the goals (i.e. [x, y, color])
        - Int rows : Number of rows in the game board
        - Int cols : Number of cols in the game board
        """
        self.walls = list()
        for wall in walls:
            self.walls.append(WallData(Coords(wall[0], wall[1])))

        self.goals = list()
        for goal in goals:
            self.goals.append(GoalData(Coords(goal[0], goal[1]), goal[2]))

        self.rows = rows
        self.cols = cols


class GameState:
    def __init__(self, common_gs, blocks):
        """
        Constructor
        - CommonGameState common_gs : GameState containing the non-movable tiles
        - List blocks : List of coordinates and colors of the blocks (i.e. [x, y, color])
        - Move move : Move that originated GameState, None if initial
        - Int nMoves : Number of moves since initial state
        """
        self.common_gs = common_gs
        self.blocks = list()
        for block in blocks:
            self.blocks.append(BlockData(Coords(block[0], block[1]), block[2]))
        self.points = -1
        self.options = None

    def __repr__(self):
        out = ""
        matrix = self.getGameStateMatrix()
        for i in matrix:
            out += "\n"
            for j in i:
                out += j + "\t"
        out += "\n"
        return out

    def getGameStateMatrix(self):
        """
        Makes A Matrix with the board
        """
        matrix = []
        for i in range(self.common_gs.rows):
            line = []
            for j in range(self.common_gs.cols):
                coord = Coords(i, j)
                tipo = "."
                for block in self.blocks:
                    if coord == block.coords:
                        tipo = block.color
                        break
                for goal in self.common_gs.goals:
                    if tipo != ".":
                        break
                    if coord == goal.coords:
                        tipo = goal.color
                        break
                for wall in self.common_gs.walls:
                    if tipo != ".":
                        break
                    if coord == wall.coords:
                        tipo = "#"
                        break
                line.append(tipo)
            matrix.append(line)
        return matrix

    def getGameStateDictionary(self):
        """
        Makes A Dictionary with the board
        """
        d = defaultdict(list)
        for block in self.blocks:
            d[block.coords].append(block.color)
        for goal in self.common_gs.goals:
            d[goal.coords].append(goal.color)
        for wall in self.common_gs.walls:
            d[wall.coords].append("#")
        return d

    def is_game_over(self):
        """
        Checks if game state is in final state, each block must match in one goal

        Returns true if represents a final state, false otherwise
        """
        for block in self.blocks:
            found = False
            for goal in self.common_gs.goals:
                if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                    found = True
                    break
            if not found:
                return False
        return True


    def swipe_left(self):
        """
        Swipe Left Operation - Moves the movable blocks in the GameState to the left

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: el.coords.y)
        moved_to_goal = 0
        moved_off_goal = 0
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            old_coords = deepcopy(block.coords)
            was_on_goal = self.is_on_goal(block)
            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y < block.coords.y,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.y)
            new_col = walls[0].coords.y + 1 if walls else 0
            self.blocks[i].coords.setY(new_col)
            
            new_coords = self.blocks[i]
            is_on_goal = self.is_on_goal(self.blocks[i])

            if (old_coords != new_coords):
                moved_off_goal += 1 if was_on_goal else 0
                moved_to_goal += 1 if is_on_goal else 0

        return moved_to_goal, moved_off_goal

    def swipe_right(self):
        """
        Swipe Right Operation - Moves the movable blocks in the GameState to the right

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: -el.coords.y)
        moved_to_goal = 0
        moved_off_goal = 0
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            old_coords = deepcopy(block.coords)
            was_on_goal = self.is_on_goal(block)

            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y > block.coords.y,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.y)
            new_col = walls[0].coords.y - 1 if walls else (self.common_gs.cols - 1)
            self.blocks[i].coords.setY(new_col)

            new_coords = self.blocks[i]
            is_on_goal = self.is_on_goal(self.blocks[i])

            if (old_coords != new_coords):
                moved_off_goal += 1 if was_on_goal else 0
                moved_to_goal += 1 if is_on_goal else 0

        return moved_to_goal, moved_off_goal


    def swipe_up(self):
        """
        Swipe Up Operation - Moves the movable blocks in the GameState upwards

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: el.coords.x)
        moved_to_goal = 0
        moved_off_goal = 0
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            old_coords = deepcopy(block.coords)
            was_on_goal = self.is_on_goal(block)

            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x < block.coords.x,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.x)
            new_row = walls[0].coords.x + 1 if walls else 0
            self.blocks[i].coords.setX(new_row)
            
            new_coords = self.blocks[i]
            is_on_goal = self.is_on_goal(self.blocks[i])

            if (old_coords != new_coords):
                moved_off_goal += 1 if was_on_goal else 0
                moved_to_goal += 1 if is_on_goal else 0

        return moved_to_goal, moved_off_goal

    def swipe_down(self):
        """
        Swipe Down Operation - Moves the movable blocks in the GameState downwards

        Returns the new GameState generated by that operation
        """
        moved_to_goal = 0
        moved_off_goal = 0
        self.blocks.sort(key=lambda el: -el.coords.x)
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            old_coords = deepcopy(block.coords)
            was_on_goal = self.is_on_goal(block)
            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x > block.coords.x,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.x)
            new_row = walls[0].coords.x - 1 if walls else (self.common_gs.rows - 1)
            self.blocks[i].coords.setX(new_row)
            
            new_coords = self.blocks[i]
            is_on_goal = self.is_on_goal(self.blocks[i])

            if (old_coords != new_coords):
                moved_off_goal += 1 if was_on_goal else 0
                moved_to_goal += 1 if is_on_goal else 0

        return moved_to_goal, moved_off_goal

    def is_on_goal(self, block):
        for goal in self.common_gs.goals:
            if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                return True
        return False

    def number_of_blocks_on_goals(self):
        n = 0
        for block in self.blocks:
            for goal in self.common_gs.goals:
                if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                    n += 1
                    break
        return n

    def euclidean_distance(self):
        dists = []
        for block in self.blocks:
            node_dists = []
            for goal in self.common_gs.goals:
                if block.color == goal.color:
                    # d = sqrt((x2-x1)**2 + (y2-y1)**2)
                    dnode = math.sqrt(
                        math.pow(block.coords.x - goal.coords.x, 2) + math.pow(block.coords.y - goal.coords.y, 2))
                    node_dists.append(dnode)
            if node_dists:
                d = min(node_dists)
            else:
                d = sys.maxsize
            dists.append(d)
        return min(dists)