from matchthetiles.gamestate.tiledata import WallData, BlockData, GoalData
from matchthetiles.utils.coords import Coords

import numpy as np

from collections import defaultdict
from copy import deepcopy
from enum import Enum
import math
import sys

class Move(Enum):
    SWIPE_LEFT = 0
    SWIPE_UP = 1
    SWIPE_RIGHT = 2
    SWIPE_DOWN = 3

    def __str__(self):
        if self.name == "SWIPE_DOWN":
            return "Down"
        if self.name == "SWIPE_LEFT":
            return "Left"
        if self.name == "SWIPE_RIGHT":
            return "Right"
        if self.name == "SWIPE_UP":
            return "Up"

class CommonGameState:
    def __init__(self, walls: list, goals: list, rows: int, cols: int):
        """
        Constructor
        - List walls : List of coordinates of the walls (i.e. [x, y])
        - List goals : List of coordinates and colors of the goals (i.e. [x, y, color])
        - Int rows : Number of rows in the game board
        - Int cols : Number of cols in the game board
        """
        self.walls = list()
        for wall in walls:
            self.walls.append(WallData(Coords(wall[0], wall[1])))

        self.goals = list()
        for goal in goals:
            self.goals.append(GoalData(Coords(goal[0], goal[1]), goal[2]))

        self.rows = rows
        self.cols = cols


class GameState:
    def __init__(self, common_gs, blocks):
        """
        Constructor
        - CommonGameState common_gs : GameState containing the non-movable tiles
        - List blocks : List of coordinates and colors of the blocks (i.e. [x, y, color])
        - Move move : Move that originated GameState, None if initial
        - Int nMoves : Number of moves since initial state
        """
        self.common_gs = common_gs
        self.blocks = list()
        for block in blocks:
            self.blocks.append(BlockData(Coords(block[0], block[1]), block[2]))
        self.points = -1
        self.options = None

    def __repr__(self):
        out = ""
        matrix = self.getGameStateMatrix()
        for i in matrix:
            out += "\n"
            for j in i:
                out += j + "\t"
        out += "\n"
        return out

    def getGameStateMatrix(self):
        """
        Makes A Matrix with the board
        """
        matrix = []
        for i in range(self.common_gs.rows):
            line = []
            for j in range(self.common_gs.cols):
                coord = Coords(i, j)
                tipo = "."
                for block in self.blocks:
                    if coord == block.coords:
                        tipo = block.color
                        break
                for goal in self.common_gs.goals:
                    if tipo != ".":
                        break
                    if coord == goal.coords:
                        tipo = goal.color
                        break
                for wall in self.common_gs.walls:
                    if tipo != ".":
                        break
                    if coord == wall.coords:
                        tipo = "#"
                        break
                line.append(tipo)
            matrix.append(line)
        return matrix

    def getGameStateDictionary(self):
        """
        Makes A Dictionary with the board
        """
        d = defaultdict(list)
        for block in self.blocks:
            d[block.coords].append(block.color)
        for goal in self.common_gs.goals:
            d[goal.coords].append(goal.color)
        for wall in self.common_gs.walls:
            d[wall.coords].append("#")
        return d

    def is_game_over(self):
        """
        Checks if game state is in final state, each block must match in one goal

        Returns true if represents a final state, false otherwise
        """
        for block in self.blocks:
            found = False
            for goal in self.common_gs.goals:
                if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                    found = True
                    break
            if not found:
                return False
        return True


    def swipe_left(self):
        """
        Swipe Left Operation - Moves the movable blocks in the GameState to the left

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: el.coords.y)
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y < block.coords.y,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.y)
            new_col = walls[0].coords.y + 1 if walls else 0
            self.blocks[i].coords.setY(new_col)

    def swipe_right(self):
        """
        Swipe Right Operation - Moves the movable blocks in the GameState to the right

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: -el.coords.y)
        for i in range(len(self.blocks)):
            block = self.blocks[i]

            walls = sorted(filter(lambda el: el.coords.x == block.coords.x and el.coords.y > block.coords.y,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.y)
            new_col = walls[0].coords.y - 1 if walls else (self.common_gs.cols - 1)
            self.blocks[i].coords.setY(new_col)

    def swipe_up(self):
        """
        Swipe Up Operation - Moves the movable blocks in the GameState upwards

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: el.coords.x)
        for i in range(len(self.blocks)):
            block = self.blocks[i]

            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x < block.coords.x,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: -el.coords.x)
            new_row = walls[0].coords.x + 1 if walls else 0
            self.blocks[i].coords.setX(new_row)
            
    def swipe_down(self):
        """
        Swipe Down Operation - Moves the movable blocks in the GameState downwards

        Returns the new GameState generated by that operation
        """
        self.blocks.sort(key=lambda el: -el.coords.x)
        for i in range(len(self.blocks)):
            block = self.blocks[i]
            walls = sorted(filter(lambda el: el.coords.y == block.coords.y and el.coords.x > block.coords.x,
                                  self.blocks[:i] + self.common_gs.walls), key=lambda el: el.coords.x)
            new_row = walls[0].coords.x - 1 if walls else (self.common_gs.rows - 1)
            self.blocks[i].coords.setX(new_row)

    def is_on_goal(self, block):
        for goal in self.common_gs.goals:
            if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                return True
        return False

    def number_of_blocks_on_goals(self):
        n = 0
        for block in self.blocks:
            for goal in self.common_gs.goals:
                if block.color.lower() == goal.color.lower() and block.coords == goal.coords:
                    n += 1
                    break
        return n

    def euclidean_distance(self):
        dists = []
        for block in self.blocks:
            node_dists = []
            for goal in self.common_gs.goals:
                if block.color == goal.color:
                    # d = sqrt((x2-x1)**2 + (y2-y1)**2)
                    dnode = math.sqrt(
                        math.pow(block.coords.x - goal.coords.x, 2) + math.pow(block.coords.y - goal.coords.y, 2))
                    node_dists.append(dnode)
            if node_dists:
                d = min(node_dists)
            else:
                d = sys.maxsize
            dists.append(d)
        return min(dists)

    @staticmethod
    def generate_game_state(n_blocks, n_walls, rows, cols, max_depth=8):
        walls = list()
        goals = list()
        blocks = list()

        level = np.zeros((rows, cols), dtype=str)

        level, walls = GameState.generate_level_walls(level, n_walls, rows, cols)
        level, goals = GameState.generate_level_goals(level, n_blocks, rows, cols)
        print(level)
        print(walls)
        print(goals)


        # return GameState

    @staticmethod
    def generate_level_walls(level, n_walls, rows, cols):
        walls = list()
        for i in range(n_walls):
        
            x = np.random.randint(0, rows)
            y = np.random.randint(0, cols)

            while (level[x, y] != ''):
                x = np.random.randint(0, rows)
                y = np.random.randint(0, cols)
            
            level[x, y] = '#'
            walls.append((x, y))    
        

        return level, walls

    @staticmethod
    def generate_level_goals(level, n_goals, rows, cols):
        goals = list()

        for i in range(n_goals):
            x = np.random.randint(0, rows)
            y = np.random.randint(0, cols)

            while True:
                if (level[x,y] == ''):
                    n_obstacles = 0
                    # Left
                    n_obstacles += (y == 0 or level[x, y - 1] != '')
                    # Right
                    n_obstacles += (y == cols - 1 or level[x, y + 1] != '')
                    # Up
                    n_obstacles += (x == 0 or level[x - 1, y] != '')
                    # Down
                    n_obstacles += (x == rows - 1 or level[x + 1, y] != '')

                    if (n_obstacles >= 1 and n_obstacles < 4): break

                x = np.random.randint(0, rows)
                y = np.random.randint(0, cols)

            level[x, y] = chr(ord('A') + i)
            goals.append((x, y, level[x, y]))

        return level, goals

    @staticmethod
    def generate_level_blocks(level, goals, rows, cols, max_steps=12):
        blocks = deepcopy(goals)

        n_blocks = len(blocks)

        


        